1) 将代码传递给方法的功能（同时也能够返回代码并将其包含在数据结构中），通常称之为函数式编程。
2) Collection主要时为了存储和访问数据，而Stream则主要用于描述对数据的计算。
3) 谓词(Predicate)：即一个返回boolean值的函数。
4) 行为参数化：让方法接受多种行为(或者战略)作为参数，并在内部使用，来完成不同的行为。就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。
5) 可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。
6) 匿名：没有明确的名称；函数：不属于特定的类，有参数列表、函数主体、返回类型以及可能的抛出的异常列表；传递：Lambda表达式可以作为参数传递给方法或者存储在变量中；简洁：无需像匿名类那样写很多模板代码。
7) Lambda没有return语句，因为已经隐含了return。表达式部分可以包含多行语句，需要使用大括号。
8) 箭头->把参数列表与Lambda主体分开。Lambda的基本语法是(parameters)->expression或者(parameters)->{statements;}.
9) 可以在函数式接口上使用Lambda表达式。函数式接口就是只定义一个抽象方法的接口。Lambda表达式直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例。
10) 函数式接口的抽象方法的签名基本上就是Lambda表达式的签名，这种抽象方法叫做函数描述符。
11) @FunctionalInterface注解表示该接口会设计成一个函数式接口。
12) 任何函数式接口都不允许抛出受检异常(checked exception)。
13) a、Predicate<T>接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean。
    b、Consumer<T>接口定义了一个名叫accept的抽象方法，它接受泛型T对象，并返回一个void。
    c、Function<T>接口定义了一个名叫apply的抽象方法，它接受泛型T对象，并返回一个泛型R对象。
14) Lambda的类型是从使用Lambda的上下文推断出来的。上下文中Lambda表达式需要的类型称为目标类型。
15) Java7中引入了菱形运算符<>，利用泛型推断从上下文推断类型的思想。比如：List<String> listOfStrings = new ArrayList<>(); List<Integer> listOfIntegers = new ArrayList<>();
16) 如果一个Lambda的主体是一个语句表达式，它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。
17) Lambda可以没有限制地捕获(也就是在其主体中引用)实例变量和静态变量，但局部变量必须显示声明为final，或者事实上是final。
18) 实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。
19) 方法引用主要有三类：
    1、指向静态方法的方法引用(例如Integer的parseInt方法，写作Integer::parseInt)
    2、指向任意类型实例方法的方法引用（例如String的length方法，写作String::length）
    3、指向现有对象的实例方法的方法引用（假设有个局部变量expensiveTransaction用于存放Transaction类型的对象，它支持实例方法getValue，那么就可以写成expensiveTransaction::getValue）
20) 对于一个现有的构造函数，可以利用它的名字和关键字new来创建它的一个引用，比如ClassName::new。它的功能与指向静态方法的引用类似。
21) 谓词复合：谓词接口包括三个方法：negate、and和or。and和or方法是按照在表达式链中的位置，从左向右确定优先级的。因此，a.or(b).and(c)可以看作(a||b)&&c.
22) 可以把Function接口所代表的Lambda表达式复合起来。andThen和compose方法。andThen方法会返回一个函数，它先对输入应用一个给定函数，再对输出应用另一个函数（从左至右运行方法，调用方法先运行，被调用方法后运行）。compose方法先把给定的函数用作compose的参数里面给定的那个函数，然后再把函数本身用于结果（从右至左运行方法，被调用方法先运行，调用方法后运行）。
23) 流:允许以声明性方式处理数据集合。通过查询语句来表达，而不是临时写一个实现。流还可以透明地并行处理。
24) Stream API特点：声明性-更简洁、更易读，可复合-更灵活，可并行-性能更好。集合支持一个新的stream方法，它可以返回一个流（接口定义在java.util.stream.Stream里），流简短的定义：从支持数据处理操作的源生成的元素序列。
  1、元素序列：流提供了一个接口，可以访问特定元素类型的一组有序值。流的目的在于表达计算。集合讲的是数据，流讲的是计算。
  2、源：流会使用一个提供数据的源，从有序集合生成流时会保留原有的顺序。
  3、数据操作处理：流的数据处理功能支持类似于数据库的操作，流操作可以顺序执行，也可以并行执行。
  4、流水线：很多流操作本身会返回一个流，这样多个操作就可以连接起来，形成一个大的流水线。
  5、内部迭代：流的迭代操作在后台进行。
25) 粗略地讲，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，它包含数据结构中目前所有的值，集合中的每个元素都得先计算出来才能添加到集合中。流则是在概念上固定的数据结构（不能添加和删除元素），其元素是按需计算的。和迭代器类似，流只能遍历一次。
26) 流和集合的另一个关键区别在于它们遍历数据的方式。使用Collection接口需要用户去做迭代，称为外部迭代，Streams使用内部迭代。Streams库的内部迭代可以自己选择一种适合硬件的数据表示和并行实现。
27) Stream接口中定义了许多操作，大致可以分为两类，可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。中间操作一般可以合并起来，在终端操作时一次性全部处理。
28) 流的使用包括三件事：一个数据源（如集合）来执行一个查询；一个中间操作链，形成一条流的流水线；一个终端操作，执行流水线，并能生成结果。
29) 
    |----------+--------------------------------------------------------------------|
    | filter   | 接受一个谓词做为参数，并返回一个包含所有符合谓词的元素的流         |
    |----------+--------------------------------------------------------------------|
    | distinct | 返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流 |
    |----------+--------------------------------------------------------------------|
    | limit    | 返回一个不超过给定长度的流。                                       |
    |----------+--------------------------------------------------------------------|
    | skip     | 返回一个扔掉前n个元素的流。                                        |
    |----------+--------------------------------------------------------------------|
30) 流支持map方法，它会接受一个函数做为参数。
31) Arrays.stream()方法可以接受一个数组并产生一个流。使用flatMap方法，各个数组并不是分别映射成一个流，而是映射成流的内容，所有使用map(Arrays::stream)时生成的单个流都被合并起来，即扁平化为一个流。总之，flatmap方法让一个流中的每个值都换成另一个流，然后把所有的流连接成为一个流。
32) 
    |-----------+------------------------------------------------|
    | anyMatch  | （终端操作）流中是否有一个元素能匹配给定的谓词 |
    |-----------+------------------------------------------------|
    | allMatch  | (终端操作)流中是否全部元素能匹配给定的谓词     |
    |-----------+------------------------------------------------|
    | noneMatch | (终端操纵)流只是否全部元素都不能匹配给定的谓词 |
    |-----------+------------------------------------------------|
    | findAny   | 返回当前流中的任意元素                         |
    |-----------+------------------------------------------------|
33) Optional<T>类(java.util.Optional)是一个容器类，代表一个值存在或者不存在。
    | isPresent()                  | 在Optional包含值的时候返回true，否则返回false     |
    |------------------------------+---------------------------------------------------|
    | ifPresent(Consumer<T> block) | 会在值存在的时候执行代码块                        |
    |------------------------------+---------------------------------------------------|
    | T get()                      | 会在值存在时返回值，否则抛出一个NoSuchElement异常 |
    |------------------------------+---------------------------------------------------|
    | T orElse(T other)            | 会在值存在时返回值，否则返回一个默认值                               |
    |                              |                                                   |
34) 将流归约成一个值，这成为折叠(fold).
    | reduce | 接受两个参数，一个是初始值，一个是BinaryOperator<T>,将两个元素结合起来产生一个新值 |
    |--------+------------------------------------------------------------------------------------|
35) 中间操纵和终端操作
    | 操作      | 类型                | 返回类型    | 使用的类型/函数式接口  | 函数描述符   |
    |-----------+---------------------+-------------+------------------------+--------------|
    | filter    | 中间                | Stream<T>   | Predicate<T>           | T->boolean   |
    |-----------+---------------------+-------------+------------------------+--------------|
    | distinct  | 中间（有状态-无界） | Stream<T>   |                        |              |
    |-----------+---------------------+-------------+------------------------+--------------|
    | skip      | 中间（有状态-有界） | Stream<T>   | long                   |              |
    |-----------+---------------------+-------------+------------------------+--------------|
    | limit     | 中间（有状态-有界） | Stream<T>   | long                   |              |
    |-----------+---------------------+-------------+------------------------+--------------|
    | map       | 中间                | Stream<R>   | Function<T, R>         | T->R         |
    |-----------+---------------------+-------------+------------------------+--------------|
    | flatMap   | 中间                | Stream<R>   | Function<T, Stream<R>> | T->Stream<R> |
    |-----------+---------------------+-------------+------------------------+--------------|
    | sorted    | 中间（有状态-无界） | Stream<T>   | Comparator<T>          | (T, T)->int  |
    |-----------+---------------------+-------------+------------------------+--------------|
    | anyMatch  | 终端                | boolean     | Predicate<T>           | T->boolean   |
    |-----------+---------------------+-------------+------------------------+--------------|
    | noneMatch | 终端                | boolean     | Predicate<T>           | T->boolean   |
    |-----------+---------------------+-------------+------------------------+--------------|
    | allMatch  | 终端                | boolean     | Predicate<T>           | T->boolean   |
    |-----------+---------------------+-------------+------------------------+--------------|
    | findAny   | 终端                | Optional<T> |                        |              |
    |-----------+---------------------+-------------+------------------------+--------------|
    | findFirst | 终端                | Optional<T> |                        |              |
    |-----------+---------------------+-------------+------------------------+--------------|
    | forEach   | 终端                | void        | Consumer<T>            | T->void      |
    |-----------+---------------------+-------------+------------------------+--------------|
    | collect   | 终端                | R           | Collector<T, A, R>     |              |
    |-----------+---------------------+-------------+------------------------+--------------|
    | reduce    | 终端（有状态-有界） | Optional<T> | BinaryOperator<T>      | (T, T)->T    |
    |-----------+---------------------+-------------+------------------------+--------------|
    | count     | 终端                | long        |                        |              |
    |-----------+---------------------+-------------+------------------------+--------------|
36) Java8引入了三个原始类型特化流接口：IntStream，DoubleStream和LongStream，分别将流中的元素特化为int、double和long，从而避免了暗含的装箱成本。将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong，只返回一个特化流，而不是Stream<T>.
37) mapToObj返回一个对象值流。
38) Stream.of通过显示值创建一个流，可以接受任意数量的参数。使用empty得到一个空流。Arrays.stream从数组创建一个流。Files.lines返回一个由指定文件中的各行构成的字符串流。
39) 从函数生成流：Stream.iterate和Stream.generate。这两个流可以产生无限流。
